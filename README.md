서버 사이드 렌더링(SSR, Server Side Rendering)과 클라이언트 사이드 렌더링(CSR, Client Side Rendering)은 </br>
웹 애플리케이션에서 웹 페이지를 어떻게 렌더링하는지에 대한 두 가지 주요 접근 방식입니다.

# 서버 사이드 렌더링 (SSR, Server Side Rendering)

    SSR은 웹 페이지의 렌더링을 서버 측에서 처리하는 방식입니다. 클라이언트가 페이지를 요청할 때, 서버에서 미리 완성된 형태의 HTML로 렌더링하여 클라이언트에게 전달합니다.
    클라이언트가 서버로 요청을 보내면 서버는 데이터를 가져오고 해당 데이터를 포함하여 HTML 페이지를 완성합니다. 클라이언트에게 렌더링된 페이지가 전달되어 브라우저에 표시됩니다.
    SSR은 초기 로딩 속도가 빠르고, SEO에 유리한 방식입니다. 브라우저에서 페이지를 렌더링하지 않고, 완전한 형태의 페이지가 전달되므로 웹 크롤러가 페이지 내용을 쉽게 수집할 수 있습니다.
    단점으로는 서버 자원을 사용하고 렌더링 시간이 더 오래 걸릴 수 있으며, 동적으로 변하는 콘텐츠의 경우에는 추가적인 서버 요청이 필요할 수 있습니다.

</br></br>

# 클라이언트 사이드 렌더링 (CSR, Client Side Rendering)

    CSR은 웹 페이지의 렌더링을 클라이언트 측에서 처리하는 방식입니다. 초기 요청 시에는 빈 페이지가 전달되며, 클라이언트에서 자바스크립트를 사용하여 동적으로 페이지를 생성합니다.
    브라우저에서 페이지를 렌더링하는 방식이므로, 초기 로딩 속도가 느리지만, 페이지 렌더링 이후에는 데이터 요청빠르게 페이지 전환과 상호작용이 가능합니다.
    CSR은 서버에 부담을 덜 주고, 웹 애플리케이션 로딩 이후에는 클라이언트에서 빠르게 동작합니다.
    단점으로는 초기 로딩 속도가 느릴 수 있고, 검색 엔진 최적화(SEO)에 불리할 수 있습니다. 초기에는 빈 페이지가 로때문에 웹 크롤러가 페이지 내용을 수집하지 못할 수 있습니다.

</br></br>

# CSS

`@include flex-between;`는 SCSS에서 믹스인(mixin)을 호출하는 구문입니다. 

믹스인은 사전에 정의된 여러 스타일 속성을 포함하는 코드 블록으로, 코드의 재사용성을 높이기 위해 사용됩니다.

`flex-between`이라는 이름의 믹스인은 아마도 Flexbox 레이아웃을 적용하면서 내부의 요소들을 공간 분배 방식으로 정렬하는 스타일을 설정하는 기능을 할 것입니다. 

보통 이러한 믹스인은 다음과 같이 정의될 수 있습니다:

```scss
@mixin flex-between {
    display: flex;
    justify-content: space-between; // 컨테이너 내의 아이템들 사이에 가능한 많은 공간을 두어 양쪽 끝으로 정렬합니다.
    align-items: center; // 아이템들을 세로 중앙에 위치시킵니다.
}
```

위의 정의를 통해, `.header__inner` 요소에 `@include flex-between;`를 적용하면, 

해당 요소는 `display: flex;` 속성을 사용하여 Flexbox 레이아웃을 채택하고, 

내부의 아이템들은 양 끝으로 정렬되면서 중앙에 맞추어지는 효과를 나타냅니다. 

이는 헤더 내의 로고나 네비게이션 링크 등을 좌우로 균등하게 배치할 때 유용하게 사용됩니다.



----

## useEffect cleanup 매커니즘

`useEffect`: 컴포넌트가 마운트 될 때 특정 동작(사이드이펙트)을 수행, 언마운트 될때 정리

```jsx
useEffect(() => {
  const slideInterval = setInterval(() => {
    setCurrentIndex((prevIndex) => (prevIndex + 1) % images.length);
  }, interval);

  return () => clearInterval(slideInterval); //CleanUp
}, [images.length, interval]);
```

- 여기서 첫 번째 인수는 사이드 이펙트 정의하는 함수
- 두 번째 인수는 의존성 배열 (변경 시 사이드 이펙트 함수 실행)

``` jsx
return () => clearInterval(slideInterval)
```
이 부분이 바로 "cleanup" 함수입니다. useEffect 내에서 반환되는 함수는 컴포넌트가 언마운트되거나, 의존성 배열의 값이 변경되어 useEffect가 재실행될 때 호출됩니다. 이 함수는 기존의 사이드 이펙트를 정리하는 역할을 합니다.


#### 왜 필요한가?

- 메모리 누수 방지: 컴포넌트가 언마운트된 후에도 setInterval이 계속 실행되는 것을 방지합니다.
- 의존성 변경 처리: images.length 또는 interval이 변경되면 기존의 setInterval을 정리하고 새로운 setInterval을 설정합니다.

#### 변경될만한 상황?

images.length나 interval이 변경되는 경우는 특정 상황에 따라 다릅니다. 예를 들어, 사용자가 슬라이드 이미지 목록을 동적으로 업데이트하거나, 슬라이드 전환 속도를 조정할 수 있는 기능을 제공할 때 변경될 수 있습니다.

-> 혹시나 사용자가 중간에 새로운 이미지 추가하거나 제거 시 length변경

-> 슬라이드 전환 속도를 동적으로 변경할 수 있으면 interval 값이 변경될 수 있다.

하지만 일반적인 슬라이드쇼에서는 이 값들이 변경될 일이 거의 없을 수 있습니다. 그렇다면 cleanup 함수와 의존성 배열의 역할을 설명하는 것이 더 의미가 있을 수 있습니다.

useEffect 훅의 의존성 배열에 images.length와 interval을 포함시키는 것은 코드의 확장성 및 유지보수를 고려한 좋은 실천 방법입니다. 이를 통해 코드가 예기치 않은 상황에서도 올바르게 동작할 수 있습니다.